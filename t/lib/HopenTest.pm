#!perl
# HopenTest.pm: test kit for App::hopen

package HopenTest;
use parent 'Exporter';
use Import::Into;

# Pragmas
use 5.014;
use feature ":5.14";
use strict;
use warnings;
use warnings;

# Packages
use Data::Dumper;
use Carp;

#use Capture::Tiny 'capture';
#use Config;
#use IPC::Run3;
use Scalar::Util qw(refaddr);
use Test::More;

#use Text::ParseWords qw(shellwords);
use Test::Spec;

use strict;
use warnings;
use Data::Hopen::Base;

BEGIN { $Data::Dumper::Indent = 1 }    # For easier-to-read dumps

# Definitions from this file
use constant {
    true  => !!1,
    false => !!0,
};

our (@EXPORT, @EXPORT_FAIL);

BEGIN {
    @EXPORT = qw(true false
      get_only_builder_node ref_equal_ok
      ck sueach);
}

=head2 get_only_builder_node

Given a Data::Hopen::G::GraphBuilder, test that it only has one current
node, and return that node

=cut

sub get_only_builder_node {
    my $builder = shift;
    is(ref $builder->nodes, 'ARRAY', 'builder->nodes is an arrayref');
    cmp_ok(@{ $builder->nodes }, '==', 1, 'nodes has one element');
    return $builder->nodes->[0];
} ## end sub get_only_builder_node

=head2 ref_equal_ok

Test if two scalars are references, and point the same place.  Fails if either
is not a reference, or if they point different places.

=cut

sub ref_equal_ok ($$;$) {
    my ($got, $expected, $test_name) = @_;
    unless(ref $got && ref $expected) {
        diag "ref_equal_ok: didn't get two references: got="
          . (ref($got) // 'not a ref')
          . ', expected=', (ref($expected) // 'not a ref');
        ok(false, $test_name);
    } ## end unless(ref $got && ref $expected)

    cmp_ok(refaddr($got), '==', refaddr($expected), $test_name);
} ## end sub ref_equal_ok ($$;$)

=head2 ck

"Check".  Shorthand for L<Test::Spec/it CODE>.  Example:

    ck { ok(true) } "works";

is identical to

    it 'works' => sub { ok(true) };

=cut

sub ck (&@) {
    if(@_ > 1) {
        my $func = shift;
        splice @_, 1, 0, $func;
    }
    goto &it;
} ## end sub ck (&@)

=head2 sueach

"Setup each." Shorthand for L<Test::Spec/before CODE>.
C<sueach { foo }> is the same as C<< before each => sub { foo } >>.

=cut

sub sueach (&) { goto &before }

sub import {
    my $target = caller;

    #my $pkg =
    shift;    # Don't need our package name

    # Keep output lines in order
    STDOUT->autoflush(true);
    STDERR->autoflush(true);

    # --- Basic exports/re-exports  ------------------------------------

    # Export all symbols listed in @EXPORT
    __PACKAGE__->export_to_level(1, __PACKAGE__);

    # Re-export pragmas and packages
    feature->import::into($target, qw(:5.14));
    Carp->import::into($target, qw(carp croak confess));
    foreach (
        qw(strict warnings Data::Dumper Test::More Test::Spec
        Data::Hopen::Base)
      )
    {
        $_->import::into($target);
    } ## end foreach (qw(strict warnings Data::Dumper Test::More Test::Spec...))

    # --- Process argument list ----------------------------------------

    # First argument: if a non-reference, the name of the package to load.
    if(@_ && $_[0] && !ref($_[0])) {
        my $dut = shift;

        # Make sure it's there
        eval "require $dut;";
        die "Could not locate DUT $dut\n$@\n" if $@;

        $dut->import::into($target);    # load it

        #Package::Alias->import::into($target, DUT => $dut);     # Load it
        # NOTE: Class::Tiny subclasses won't construct properly if called via
        # a package alias (e.g., DUT->new).  Therefore, don't do the alias.

        {    # Export the name of the DUT package as the caller's $DUT
            no strict 'refs';
            *{ $target . '::DUT' } = eval qq(\\"$dut");    # eval => constant
        }

        diag "DUT is $dut";
    } ## end if(@_ && $_[0] && !ref...)

} ## end sub import

1;

# vi: set ts=4 sts=0 sw=4 ai fdm=marker fdl=1: #
