# App::hopen::Gen::Make - generator for a generic make(1).
package App::hopen::Gen::Make;
use strict; use warnings;
use Data::Hopen::Base;

our $VERSION = '0.000013'; # TRIAL

use parent 'App::hopen::Gen';   # and Class::Tiny below

use App::hopen::BuildSystemGlobals;
use App::hopen::Phases qw(is_gen_phase);
use App::hopen::Util::String qw(line_mark_string);
use Data::Hopen qw(:default getparameters *QUIET *VERBOSE);
use Data::Hopen::Scope::Hash;
use Data::Hopen::Util::Data qw(forward_opts);
use Data::Section::Simple qw(get_data_section);
use File::Which;
use Quote::Code;    # TODO replace Quote::Code with pure-Perl for fatpackability
use Text::MicroTemplate;
use Tie::RefHash;

use Class::Tiny {
    # Cache templates from __DATA__ since Data::Section::Simple doesn't
    _templates => sub { get_data_section },
    # Cache renderers
    _renderers => sub { +{} },
};

# Docs {{{1

=head1 NAME

App::hopen::Gen::Make - hopen generator for simple Makefiles

=head1 SYNOPSIS

This generator makes a Makefile that does its best to run on cmd.exe or sh(1).

=head1 FUNCTIONS

=cut

# }}}1

# Make a renderer for a given template
my $_renderer_idx = 0;
sub _renderer {
    my ($self, $name) = @_;
    unless($self->_renderers->{$name}) {
        # Thanks to the T::MT docs for this workflow
        my $code = Text::MicroTemplate->new(
            template => $self->_templates->{$name},
            escape_func => undef,
            package_name => '__R_GenMake_Renderer_' . $_renderer_idx++,
        )->code;
        $self->_renderers->{$name} = eval line_mark_string <<"EOT";
            sub {
                my %v;  # basic variable unpacking --- accept a hashref
                %v = %{\$_[0]} if ref \$_[0] eq 'HASH';
                $code->()
            }
EOT
        die "Could not create template: $@" if $@;
        hlog { "Template renderer for $name", $code } 3;
    }
    return $self->_renderers->{$name};
}

=head2 _finalize

Write out the Makefile.  Usage:

    $Generator->_finalize(-phase => $phase, -graph => $dag);    # $data parameter unused

C<$dag> is the build graph.

=cut

sub _finalize {
    my ($self, %args) = getparameters('self', [qw(phase graph; data)], @_);
    hlog { Finalizing => __PACKAGE__ , '- phase', $args{phase} };
    return unless is_gen_phase $args{phase};

    hlog { __PACKAGE__, 'Assets:', join ', ',
            map { $_->target } keys %{$self->_assets}
    } 3;

    # During the Gen phase, create the Makefile
    open my $fh, '>', $self->dest_dir->file('Makefile') or die "Couldn't create Makefile";
    print $fh <<EOT;
# Makefile generated by hopen (https://github.com/hopenbuild/App-hopen)
# at @{[scalar gmtime]} GMT
# From ``@{[$self->proj_dir->absolute]}'' into ``@{[$self->dest_dir->absolute]}''

.PHONY: first__goal__
EOT

    # Make sure the first goal is 'all' regardless of order.
    say $fh qc'first__goal__: {$args{graph}->default_goal->name}\n';

    # Make the Make-friendly name ("tag") of each of the assets we have
    tie my %tags, 'Tie::RefHash';
    foreach my $asset (keys %{$self->_assets}) {

        # Goals
        unless($asset->isdisk) {
            $tags{$asset} = $asset->target;
            next;
        }

        # Files
        my $output = $asset->target;
        $output = $output->path_wrt($self->dest_dir) if eval { $output->DOES('App::hopen::Util::BasedPath') };
        $tags{$asset} = $output;
    }

    # Write the Makefile goals and recipes.
    # Arbitrary choice: alphabetical order
    my @assets = sort { $a->name cmp $b->name } keys %{$self->_assets};
    $self->_emit_asset($_, \%tags, $fh) foreach @assets;

    close $fh;
} #_finalize()

sub _emit_asset {
    my ($self, $asset, $tags, $fh) = @_;

    if($VERBOSE) {
        hlog { __PACKAGE__, 'Emitting asset', $asset->target } 3;
        print $fh $self->_renderer('verbose.tt')->({ asset => $asset });
    }

    my $output = $tags->{$asset};
    my @prereq_tags = map { $tags->{$_} } @{$asset->made_from};
    my $recipe = $asset->how;

    return unless @prereq_tags || $recipe;

    if(defined $asset->how) {
        # TODO RESUME HERE refactor this processing into a template
        $recipe =~ s<#first\b><$prereq_tags[0] // ''>ge;      # first input
        $recipe =~ s<#all\b><join(' ', @prereq_tags)>ge;      # all inputs
        $recipe =~ s<#out\b><$output // ''>ge;
    }

    # Emit the entry.  If the recipe is defined but falsy,
    # this is a goal, so it gets a .PHONY.
    # TODO move into a template
    print $fh qc_to <<"EOT";
#{$asset->isdisk ? '' : ".PHONY: " . $tags->{$asset}}
#{$output}: #{join(" ", @prereq_tags)}
#{$recipe ? "\t$recipe" : ''}

EOT
}

=head2 _default_toolset

Returns the package name of the default toolset for this generator,
which is C<Gnu> (i.e., L<App::hopen::T::Gnu>).

=cut

sub _default_toolset { 'Gnu' }

=head2 _run_build

Implementation of L<App::hopen::Gen/run_build>.

=cut

sub _run_build {
    # Look for the make(1) executable.  Listing make before gmake since a
    # system with both Cygwin and Strawberry Perl installed has cygwin's
    # make(1) and Strawberry's gmake(1).
    foreach my $candidate (qw[make gmake mingw32-make dmake]) {
        my $path = File::Which::which($candidate);
        next unless defined $path;
        hlog { Running => $path };
        system $path, ();
        return;
    }
    warn "Could not find a 'make' program to run";
} #_run_build()

1;
__DATA__

@@ verbose.tt
# Makefile piece from node <?= $v{asset}->name ?>: <?= $v{asset}->target ?>
#   <? if($v{asset}->how) { ?>Recipe: <?= $v{asset}->how ?><? } else { ?><?= '<no recipe>' ?><? } ?>
<? my $deps = join ', ', map { $_->target } @{$v{asset}->made_from}; ?>
#   Depends on <?= $deps || "nothing" ?>

@@ __ignore__
# vi: set fdm=marker: #
