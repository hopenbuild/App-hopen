# App::hopen::Util::GenWithoutAssetGraph - abstract base for generators without asset graphs
package App::hopen::Util::GenWithoutAssetGraph;
use strict;
use warnings;
use Data::Hopen::Base;

our $VERSION = '0.000013';    # TRIAL

use parent 'App::hopen::Gen'; # and Class::Tiny below

use App::hopen::AppUtil qw(:constants);
use App::hopen::Asset;
use App::hopen::BuildSystemGlobals;
use App::hopen::Util::Templates;
use Data::Hopen qw(:default getparameters *QUIET *VERBOSE);
use Data::Hopen::Scope::Hash;
use Data::Hopen::Util::Data qw(forward_opts);
use File::Which;
use Tie::RefHash;

use Class::Tiny {

    # _assets, sorted assetwise
    _sorted_assets => sub { [] },

    # Tags of the assets.  A Tie::RefHash.
    _tags => undef,

    # targets not representing files on disk
    _phony => sub { [] },
};

# Docs {{{1

=head1 NAME

App::hopen::Util::GenWithoutAssetGraph - abstract base for generators without asset graphs

=head1 SYNOPSIS

This is a parent class for generators that operate on the list of assets
(L<App::Hopen::Gen/_assets>) without needing to expressly consider the
relationships between those assets.

=cut

# }}}1

=head1 FUNCTIONS TO BE IMPLEMENTED IN SUBCLASSES

Subclasses must implement L<App::hopen::Gen/_default_toolset> and
L<App::hopen::Gen/_run_build>.  In addition: subclasses may/must implement:

=head2 _filename

(Required) Returns the name of the file to generate (e.g, C<Makefile>).

=head2 _do_preamble

(Optional; default no-op) Takes any action desired after writing the file
header, and before writing the assets.  Invoked as
C<< $self->_do_preamble($filehandle, $graph) >>.

=head2 _do_asset_info

(Optional; default no-op) Emit any non-operational information for an asset
(e.g., Makefile comments).
Invoked as C<< $self->_do_asset_info($fh, $asset) >>.

=head2 _do_asset

(Required) Emit the build information for an asset.
Invoked as C<< $self->_do_asset($fh, $asset, \@prereq_tags) >>,
where C<@prereq_tags> is a list of the C<< $self->_tags >> values of
C<< $asset->made_from >> (provided for convenience).

=head2 _do_postamble

(Optional; default no-op) Takes any action desired after writing the assets.
Invoked as C<< $self->_do_postamble($filehandle, $graph) >>.

=cut

sub _filename { ... }

sub _do_preamble { }

sub _do_asset_info { }

sub _do_asset { ... }

sub _do_postamble { ... }

=head1 FUNCTIONS

=head2 _finalize

Write out the Makefile.  Usage:

    $Generator->_finalize(-phase => $phase, -graph => $graph, -data => $data);

C<$graph> is the build graph.  Only does anything during the Gen phase.

=cut

sub _finalize {
    my ($self, %args) = getparameters('self', [qw(phase graph; data)], @_);
    hlog { Finalizing => ref($self), '- phase', $args{phase} };
    return unless PHASES->is($args{phase}, 'gen');

    $self->_populate_attributes;

    # During the Gen phase, create the Makefile
    my $fn = $self->_filename;
    open my $fh, '>', $self->dest_dir->file($fn)
      or die "Couldn't create $fn";

    print $fh <<EOT;
# $fn generated by hopen (https://github.com/hopenbuild/App-hopen)
# at @{[scalar gmtime]} GMT
# From ``@{[$self->proj_dir->absolute]}'' into ``@{[$self->dest_dir->absolute]}''

EOT

    $self->_do_preamble($fh, $args{graph});

    $self->_emit_asset($fh, $_) foreach @{ $self->_sorted_assets };

    $self->_do_postamble($fh, $args{graph});

    close $fh;
} ## end sub _finalize

sub _populate_attributes {
    my $self = shift;

    # Make _sorted_assets
    my @assets = sort App::hopen::Asset::assetwise keys %{ $self->_assets };
    @{ $self->_sorted_assets } = @assets;
    hlog { __PACKAGE__, 'Assets:', join ', ', map { $_->target } @assets } 3;

    # Make _tags: system-friendly names of each of the assets we have,
    # and fill in _phony
    tie my %tags, 'Tie::RefHash';
    foreach my $asset (keys %{ $self->_assets }) {

        # Goals
        unless($asset->isdisk) {
            $tags{$asset} = $asset->target;
            push @{ $self->_phony }, $tags{$asset};
            next;
        }

        # Files
        my $output = $asset->target;
        $output = $output->path_wrt($self->dest_dir)
          if eval { $output->DOES('App::hopen::Util::BasedPath') };
        $tags{$asset} = $output;
    } ## end foreach my $asset (keys %{ ...})

    $self->_tags(\%tags);
} ## end sub _populate_attributes

sub _emit_asset {
    my ($self, $fh, $asset) = @_;

    if($VERBOSE) {
        hlog { __PACKAGE__, 'Emitting asset', $asset->target } 3;
        $self->_do_asset_info($fh, $asset);
    }

    my @prereq_tags = map { $self->_tags->{$_} } @{ $asset->made_from };
    my $recipe      = $asset->how;

    return unless @prereq_tags || $asset->how;

    $self->_do_asset($fh, $asset, \@prereq_tags);
}    # sub _emit_asset()

1;
__END__
# vi: set fdm=marker: #
